%% Protobuf usage examples for Erlang
%% - show two common generation/runtime variants:
%%   1) protoc + protoc-gen-erlang -> generated module names like cross_envelope_pb or envelope_pb
%%   2) gpb runtime usage (gpb:encode/2, gpb:decode/2) when you prefer not to depend on generated encode/1 functions
%%
%% Replace calls to generated modules with actual names produced by your generator.

-module(proto_examples).
-export([
    encode_envelope_protoc/4,
    decode_envelope_protoc/1,
    encode_envelope_gpb/4,
    decode_envelope_gpb/1
]).

-include_lib("kernel/include/logger.hrl").

%% --- Variant A: using code generated by protoc + protoc-gen-erlang (common name pattern: cross_envelope_pb or envelope_pb)
%% Assumes generator produces functions like Envelope:encode/1 and Envelope:decode/1,
%% or module cross__envelope_pb:encode_envelope/1 (adjust per your tool).
%%
%% Example usage (adjust module/function names to your generator):
%%
%%   Bin = proto_examples:encode_envelope_protoc(MsgId, MsgType, "account.login", BodyBin).
%%   {ok, EnvelopeMap} = proto_examples:decode_envelope_protoc(Bin).

%% Replace 'cross_envelope_pb' below with the actual generated module name.
-define(GEN_MODULE, cross_envelope_pb).

encode_envelope_protoc(MsgId, MsgType, Route, BodyBin) ->
    %% Build a map or record according to generated API. Many generators accept maps.
    EnvelopeMap = #{
        msg_id => MsgId,
        msg_type => MsgType,
        route => Route,
        body => BodyBin
    },
    %% Example function name: encode_envelope/1 (may differ, adjust to generated API)
    %% If your generated module exposes encode/1: replace with ?GEN_MODULE:encode(EnvelopeMap)
    try
        %% try common variants
        case catch ?GEN_MODULE:encode_envelope(EnvelopeMap) of
            {'EXIT', _} ->
                ?GEN_MODULE:encode(envelope, EnvelopeMap); % maybe gpb-style
            Bin when is_binary(Bin) ->
                Bin
        end
    catch
        _:_ ->
            %% Fallback: try encode/1
            ?GEN_MODULE:encode(EnvelopeMap)
    end.

decode_envelope_protoc(Bin) when is_binary(Bin) ->
    %% Attempt decode variants. Adjust based on your generated module API.
    try
        case catch ?GEN_MODULE:decode_envelope(Bin) of
            {'EXIT', _} ->
                ?GEN_MODULE:decode(envelope, Bin);
            Map when is_map(Map) -> {ok, Map}
        end
    catch
        _:Reason ->
            {error, Reason}
    end.

%% --- Variant B: using gpb runtime (if you use gpb which allows runtime encode/decode by type name)
%% gpb provides gpb:encode/2 and gpb:decode/2; the type name typically "cross.Envelope" (package + type).
%% Ensure you have gpb in your deps and descriptors loaded (gpb:load/1 or gpb:compile(...)).
%%
%% Example:
%%   Bin = proto_examples:encode_envelope_gpb(MsgId, MsgType, "route", BodyBin).
%%   {ok, Map} = proto_examples:decode_envelope_gpb(Bin).
%%

encode_envelope_gpb(MsgId, MsgType, Route, BodyBin) ->
    TypeName = "cross.Envelope",
    Map = #{msg_id => MsgId, msg_type => MsgType, route => Route, body => BodyBin},
    %% gpb:encode/2 expects type name and map, returns binary
    case catch gpb:encode(TypeName, Map) of
        Bin when is_binary(Bin) -> Bin;
        {'EXIT', Reason} -> {error, Reason}
    end.

decode_envelope_gpb(Bin) when is_binary(Bin) ->
    TypeName = "cross.Envelope",
    case catch gpb:decode(TypeName, Bin) of
        Map when is_map(Map) -> {ok, Map};
        {'EXIT', Reason} -> {error, Reason}
    end.